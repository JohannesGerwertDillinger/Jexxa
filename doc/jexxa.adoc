= Jexxa - A hexagonal software architecture for your application
:source-highlighter: coderay
:toc:
:toclevels: 4


ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]


// Verwende Symbole für IMPORTANT, NOTE, ...
:icons: font
// Aktivieren von Anchors für jede Section
:sectanchors:

//Hinweis: Die counter:local-table-number und counter:local-figure-number werden verwendet, damit im Fliesstext als Referenz die Nummer der Tabelle bzw. Abbildung angezeigt wird, also z.B. "wie in Abbildung 5 zu sehen ist"


:numbered:



== Vision
Jexxa is a lightweight framework to implement business applications based on a https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/[ports and adapters] architecture. It shows how to easily connect technology stacks, called adapters, to interfaces of a technology agnostic business application which are called ports. For this purpose Jexxa offers:

* A lightweight core which manages the lifecycle of both ports and adapters.
* A well-defined interface to integrate arbitrary technology stacks.
* A fluent API that explicitly represents the binding between technology stacks and domain components within the main method of an application.

Even though Jexxa is used within lightweight business applications and microservices it has a strong educational focus. Jexxa has special focus on following paradigms:

* _Dependency Inversion_: Get an idea how to strictly separate between technology stacks and domain logic on a code basis which is essential for durable business applications.

* _Simplicity_: Be aware which technology stacks you really require to realize the use cases of your customers. Typically, they are quite less than expected. Keep different technology stacks loosely coupled and make it as easy as possible to replace them for your or the succeeding team maintaining the application.

* _Inversion of Control_: Find the required degree of inversion of control for your software projects. Only control aspects that are technically required but not important for your business application should be hidden by a framework. The remaining required aspects should be explicitly represented.

Even if you use real powerful frameworks for good reason within your application I hope that you find Jexxa helpful in some way.

== Motivation
The main motivation to develop this framework comes from experiences with developing and maintaining durable software systems running up to 40 years. Here, the role of a sustainable software architecture becomes an important part to support and guide the developer team which is currently responsible for this application.

Existing frameworks such as the https://spring.io[Spring Framework] or the J2EE standard provide powerful features and greatly support development of complex business applications. On the other side, these frameworks can unintentionally be misused by developers from an architectural point of view. It is quite hard to maintain applications over several decades especially if such frameworks are used inside the business application.

When developing applications with a high durability as used in production, financial or insurance sector it is highly recommended using an architecture with a strict focus on separating technology stacks from the application core, such as ports and adapters. Within the application core, developers should only use standard language features or libraries/SDKs shipped with a programming language. Available frameworks should be used to attach the latest technology stacks to the application core.

Applications without well-defined boundaries between technology stacks and application core become hard to maintain because changes on one side could (and in reality will) affect the other side. Typical symptoms are:

* Updating to a newer version of a technology stack is hard or even impossible so that it is much safer to use the old one. New developed applications of course use this old version as well because your team 'trusts' it, and you avoid maintaining a zoo of different versions.

* Adding or replacing a technology stack is hard or even impossible so that a disruptive technology causes that your application core becomes legacy as well. A common example are database technologies that have typically found their way into companies in the following chronological order: Hierarchical DBs -> relational DBs -> a zoo of NoSQL DBs. Since database technologies can become crucial for your business your company employs developers on a senior grade who have deep knowledge of the outdated and new technology stacks and synchronize your business data.

* Changes on the application core itself takes much longer time as in the beginning. In the end you need senior developers who have a deep understanding of the specific business domain, the used technology stacks and the convoluted structures of the entire application.

* In the long run such structural issues could (and in reality will) affect your enterprise architecture so that neighbored systems need to be aware and take special actions for legacy systems.  


== General Building Blocks

Jexxa has a strong focus on Domain Driven Design and uses a lot of terminology from its strategic and tactical design. An application that is build on Jexxa provides components that belong either to the __application core__ or to the  __infrastructure__. The __application core__ includes the business logic whereas the __infrastructure__ provides required technology stacks.


<<JexxaComponents>> shows the components provided by Jexxa, and their dependencies to an application core. The components are described in more detail in <<JexxaComponentDescription>>.


[plantuml, diagram-components, svg, align=center]
[reftext="Figure {counter:local-figure-number}"]
.Interaction and Dependencies of components in Jexxa. It shows that the application core has no knowledge of the infrastructure and thus is completely technology agnostic.
[[JexxaComponents]]
....
skinparam PackagePadding 20

package JexxaCore <<Infrastructure>> {
[Dependency Injection] <<Factory>>
}

package JexxaAdapter <<Infrastructure>> {
[Generic Driving Adapters]  <<Driving Adapter>>
[Specific Driving Adapters] <<Driving Adapter>>
[Driven Adapter Strategies] <<Driven Adapter Strategies>>
}

package ApplicationCore <<Application>> {
[Inbound Ports] <<Port>>
[Outbound Ports] <<Port>>
}

package Infrastructure <<Application>> {
[Port Adapters] <<Driving Adapter>>
[Driven Adapters] <<Driven Adapter>>
}

[Specific Driving Adapters] o-right-> [Port Adapters]
[Generic Driving Adapters] o-right-> [Inbound Ports]

[Port Adapters] *-right-> [Inbound Ports]
[Inbound Ports] o-down-> [Outbound Ports]
[Outbound Ports] <|.. [Driven Adapters]
[Driven Adapters] o-left-[Driven Adapter Strategies]

[Dependency Injection] ..> Infrastructure : create
[Dependency Injection] ..> ApplicationCore : create
[Dependency Injection] ..> JexxaAdapter : create

[Generic Driving Adapters] -[hidden]- [Port Adapters]
[Generic Driving Adapters] -[hidden]- [Specific Driving Adapters]
[Specific Driving Adapters] -[hidden]- [Driven Adapter Strategies]
[Port Adapters] -[hidden]- [Driven Adapters]

....



[cols="1,2,2"]
[reftext="Table {counter:local-table-number}"]
[[JexxaComponentDescription]]
|===
a|Components
|General Description
|Support by Jexxa


a| Driving Adapter
a| A driving adapter belongs to the infrastructure and receives a command from a specific client such as a UI, or a console and forwards it to a specific port.
a| Providing __generic__ driving adapters that encapsulate the receiving technology and automatically expose the methods from connected inbound ports by using a convention.

Providing __receiving__ driving adapters that include only a receiving technology and can be connected to a __port adapter__ which is implemented in the infrastructure of the application.


a|Inbound Port
| An inbound port belongs to the application core and provides use cases that can be started by a driving adapter. Depending on the design of your application core this might be an interface, or a concrete implementation of the use cases.
|Instantiation of inbound ports in the main of the application including dependency injection of required outbound ports.

a|Outbound Port
a| An outbound port belongs to the application core but only as interface. This interface is implemented in the infrastructure of the application core by using a specific technology stack such as a database driver.


a| Outbound ports are 'just' interfaces. So there is no special support in Jexxa.

IMPORTANT: Since the outbound port belongs to the application, its methods should reflect the domain language of the application core.

|Driven Adapter

|A driven adapter belongs to the infrastructure and is a concrete implementation of a specific outbound port. A driven adapter is injected into the application core which in turns only knows about the interface.
| Providing _driven adapter strategies_ to simplify development of driven adapters of the application.

Exchanging a concrete technology strategy depending on your production requirements and/or on your software development process. For example, you can easily switch your database technology between in memory, JDBC, or key value without changing your driven adapters.


| Port Adapter

| A port adapter allows for mapping between different representational styles of a specific port. For example this is required if a port should be exposed via a RESTful API. A port adapter belongs to the infrastructure of the application and is connected to a receiving driving adapter. 
| Providing receiving driving adapters that simplify the development of the port adapters.


|===


== Conventions used in Jexxa

Within Jexxa we use several conventions which are related to dependency injection. In contrast to other frameworks Jexxa does not use or offer annotations for dependency injection at all. The reason is to avoid a tight coupling between the application core and Jexxa itself. Therefore, we use conventions to perform dependency injection. In addition, these conventions define some kind of guard rails to clarify the single responsibility of the components.

[cols="1,3,2"]
|===
a|Components
|Conventions
|Reason


a| Generic Driving Adapter
a| 1. To create a Driving Adapter by Jexxa, one of the following constructors must be available (checked in this order).
* Public Default constructor
* Public constructor with a single `Properties` attribute
* Public static factory method that gets no parameters and returns the type of the driving adapter
* Public static factory method with a single `Properties` parameter and returns the type of the requested driving adapter

2. A Generic driving adapter is managed as singleton and reused when it is bind to different ports.


a|
1. Using constructors or factory methods do not require any special annotations. Using `Properties` is a standard approach in Java to provide configuration information. Note: A driving adapter gets the same `Properties` object as `JexxaMain`.

2. Is required because a generic driving adapter also encapsulates the transport mechanism which typically binds other resources like a network port. Therefore, a second instance at least with same configuration is not supported at the moment.

a|Inbound Port
a|
1. A single public constructor.
2. Parameters of the constructor must be interfaces of required outbound ports.
3. An Inbound port is managed as singleton and reused if it is connected to different driving adapters.

NOTE: Jexxa also allows to bind ports that are manually created in main. This is only recommended if your application core needs any special configuration

a|
1. Avoids ambiguity when choosing the constructor.  
2. Ports should be self-contained as much as possible. Therefore only outbound ports should be hand in. This ensures that the infrastructure is agnostic to domain logic and knows only the __interfaces__ required by the application core but not any other inner components. Therefore, only outbound ports are allowed as parameters in a constructor.
3.
* Simplifies synchronization of parallel processing from different driving adapters.
* Supports designing stateless ports


a|Outbound Port
a| None
a| None


|Driven Adapter

a| 1. Only a single driven adapter implements a specific outbound port.
2. To create a Driven Adapter by Jexxa, one of the following constructors must be available (checked in this order):
* Public default constructor
* Public constructor with a single `Properties` attribute
* Public static factory method that gets no parameters and returns the type of the Outbound Port (and not the type of the driven adapter)
* Public static factory method with a single `Properties` parameter and returns the type of the outbound port (and not the type of the driven adapter).

a| 1. Avoids ambiguity when choosing a Driven Adapter. At the moment you can only limit the search space of driven adapters on a package level.

2. Using constructors or factory methods do not require any special annotations.



| Port Adapter
a| 1. A single public constructor with a single attribute. The attribute is the concrete type of a specific port.
a| 1. A port adapter is tightly coupled to a specific port. Therefore, it gets its concrete type injected.

|===

