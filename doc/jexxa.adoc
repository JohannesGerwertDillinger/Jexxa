= Jexxa - A hexagonal software architecture for your application
:source-highlighter: coderay
:toc:
:toclevels: 4


ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]


// Verwende Symbole für IMPORTANT, NOTE, ...
:icons: font
// Aktivieren von Anchors für jede Section
:sectanchors:

//Hinweis: Die counter:local-table-number und counter:local-figure-number werden verwendet, damit im Fliesstext als Referenz die Nummer der Tabelle bzw. Abbildung angezeigt wird, also z.B. "wie in Abbildung 5 zu sehen ist"


:numbered:



== Vision
Jexxa is a lightweight framework to implement business applications based on a https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/[ports and adapters] architecture. It shows how to easily connect technology stacks, called adapters, to interfaces of a technology agnostic business application which are called ports. For this purpose Jexxa offers:

* A lightweight core which manages the lifecycle of both ports and adapters.
* A well-defined interface to integrate arbitrary technology stacks.
* A fluent API that explicitly represents the binding between technology stacks and domain components within the main method of an application.

Even though Jexxa is used within lightweight business applications and microservices it has a strong educational focus, especially on  following paradigms:

* _Dependency Inversion_: Get an idea how to strictly separate between technology stacks and domain logic on a code basis which is essential for durable business applications.

* _Simplicity_: Be aware which technology stacks you really require to realize the use cases of your customers. Typically, they are quite less than expected. Keep different technology stacks loosely coupled and make it as easy as possible to replace them for your or the succeeding team maintaining the application.

* _Inversion of Control_(IoC): Find the required degree of IoC for your software projects. Control aspects that are technically required but not important for your business application should be hidden by a framework. The remaining required aspects should be explicitly represented.

Even if you use real powerful frameworks for good reason within your application I hope that you find Jexxa helpful in some way.

== Motivation
The main motivation to develop this framework comes from experiences with developing and maintaining durable software systems running up to 40 years. Here, the role of a sustainable software architecture becomes an important part to support and guide the developer team which is currently responsible for this application.

Existing frameworks such as the https://spring.io[Spring Framework] or the J2EE standard provide powerful features and greatly support development of complex business applications. On the other side, these frameworks can unintentionally be misused by developers from an architectural point of view. It is quite hard to maintain applications over several decades especially if such frameworks find their way inside the business application.

When developing applications with a high durability as used in production, financial or insurance sector it is highly recommended using an architecture with a strict focus on separating technology stacks from the application core, such as ports and adapters. Within the application core, developers should only use standard language features or libraries/SDKs shipped with a programming language. Available frameworks should be used to attach the latest technology stacks to the application core.

Applications without well-defined boundaries between technology stacks and application core become hard to maintain because changes on one side could (and in reality will) affect the other side. Typical symptoms are:

* Updating to a newer version of a technology stack is hard or even impossible so that it is much safer to use the old one. New developed applications of course use this old version as well because your team 'trusts' it, and you avoid maintaining a zoo of different versions.

* Adding or replacing a technology stack is hard or even impossible so that a disruptive technology causes that your application core becomes legacy as well. A common example are database technologies that have typically found their way into companies in the following chronological order: Hierarchical DBs -> relational DBs -> a zoo of NoSQL DBs. Since database technologies can become crucial for your business your company employs developers on a senior grade who have deep knowledge of the outdated and new technology stacks and synchronize your business data.

* Changes on the application core itself takes much longer time as in the beginning. In the end you need senior developers who have a deep understanding of the specific business domain, the used technology stacks and the convoluted structures of the entire application.

* In the long run such structural issues could (and in reality will) affect your enterprise architecture so that neighbored systems need to be aware and take special actions for legacy systems.  


== General Building Blocks

Jexxa has a strong focus on Domain Driven Design and uses a lot of terminology from its strategic and tactical design. An application that is build on Jexxa provides components that belong either to the __application core__ or to the  __infrastructure__. The __application core__ includes the business logic whereas the __infrastructure__ provides required technology stacks.


<<JexxaComponents>> shows the components provided by Jexxa, and their dependencies to an application core. The components are described in more detail in <<JexxaComponentDescription>>.

[plantuml, images/JexxaComponents, svg, align=center]
[reftext="Figure {counter:local-figure-number}"]
.Interaction and Dependencies of components in Jexxa. It shows that the application core has no knowledge of the infrastructure and thus is completely technology agnostic.
[[JexxaComponents]]
....
skinparam PackagePadding 20

!include images/JexxaComponents.iuml

....



[cols="1,2,2"]
[reftext="Table {counter:local-table-number}"]
[[JexxaComponentDescription]]
|===
a|Components
|General Description
|Realization in Jexxa


a| Driving Adapter
a| A driving adapter belongs to the infrastructure and receives a command from a specific client such as a UI, or a console and forwards it to a specific port.
a| A __generic__ driving adapter encapsulates a communication technology and automatically exposes methods from connected inbound ports by using a convention. For example this can be used for an RPC mechanism.

A __specific__ driving adapter includes only a communication technology. It can be connected to a __port adapter__ which is implemented in the infrastructure of the application. The port adapter then performs a port specific mapping to expose a specific port or its method to clients. This is typically required for RESTfulHTTP 


a|Inbound Port
| An inbound port belongs to the application core and provides use cases that can be started by a driving adapter. Depending on the design of your application core this might be an interface, or a concrete implementation of the use cases.
a| * Jexxa provides implicit constructor injection for your inbound ports which is described in <<Dependency Injection (DI)>>.
* Jexxa also allows to instantiate and manage ports by yourself an just use provided driving and driven adapter.   

a|Outbound Port
a| An outbound port belongs to the application core but only as interface. This interface is implemented in the infrastructure of the application core by using a specific technology stack such as a database driver.


a| Outbound ports are 'just' interfaces that must be defined by your application core. Jexxa provides support to implement these interfaces. See tab __Driven Adapter Strategies__


|Driven Adapter

|A driven adapter belongs to the infrastructure and is a concrete implementation of a specific outbound port. A driven adapter is injected into the application core which in turns only knows about the interface.
| Providing _driven adapter strategies_ to simplify development of driven adapters of the application.

Exchanging a concrete technology strategy depending on your production requirements and/or on your software development process. For example, you can easily switch your database technology between in memory, JDBC, or key value without changing your driven adapters.


| Port Adapter

| A port adapter allows for mapping between different representational styles of a specific port. For example this is required if a port should be exposed via a RESTful API. A port adapter belongs to the infrastructure of the application and is connected to a receiving driving adapter. 
| Providing receiving driving adapters that simplify the development of the port adapters.


|===


== Inversion of Control (IoC)

=== Dependency Injection (DI)

Jexxa provides a simple DI mechanism to instantiate inbound ports of a business application and to inject implementations of the required outbound ports. Within Jexxa we only support _implicit constructor injection_ for following reason:

* Constructor injection ensures that the required dependencies required for the object to function properly are available at the moment the object is created.

* Fields assigned in the constructor can be final so that the object can be immutable or protect the required fields.

* No special annotation is required so that the application core remains completely decoupled from Jexxa. In addition, no special config files are required.

Within Jexxa we use conventions described in <<JexxaConventions>> which are related to dependency injection. Compared to other frameworks the limitation to constructor injection could be considered puristic but together with these conventions you get good guard rails to clarify the single responsibility of your ports.

[cols="1,3,2"]
[reftext="Table {counter:local-table-number}"]
[[JexxaConventions]]
|===
a|Components
|Conventions
|Reason


a| Generic Driving Adapter
a| 1. To create a Driving Adapter by Jexxa, one of the following constructors must be available (checked in this order).
* Public Default constructor
* Public constructor with a single `Properties` attribute
* Public static factory method that gets no parameters and returns the type of the driving adapter
* Public static factory method with a single `Properties` parameter and returns the type of the requested driving adapter

2. A Generic driving adapter is managed as singleton and reused when it is bind to different ports.


a|
1. Using constructors or factory methods do not require any special annotations. Using `Properties` is a standard approach in Java to provide configuration information. Note: A driving adapter gets the same `Properties` object as `JexxaMain`.

2. Is required because a generic driving adapter also encapsulates the transport mechanism which typically binds other resources like a network port. Therefore, a second instance at least with same configuration is not supported at the moment.

a|Inbound Port
a|
1. A single public constructor.
2. Parameters of the constructor must be interfaces of required outbound ports.
3. An Inbound port is managed as singleton and reused if it is connected to different driving adapters.

NOTE: Jexxa also allows to bind ports that are manually created in main. This is only recommended if your application core needs any special configuration

a|
1. Avoids ambiguity when choosing the constructor.  
2. Ports should be self-contained as much as possible. Therefore only outbound ports should be hand in. This ensures that the infrastructure is agnostic to domain logic and knows only the __interfaces__ required by the application core but not any other inner components. Therefore, only outbound ports are allowed as parameters in a constructor.
3.
* Simplifies synchronization of parallel processing from different driving adapters.
* Supports designing stateless ports


a|Outbound Port
a| None
a| None


|Driven Adapter

a| 1. Only a single driven adapter implements a specific outbound port.
2. To create a Driven Adapter by Jexxa, one of the following constructors must be available (checked in this order):
* Public default constructor
* Public constructor with a single `Properties` attribute
* Public static factory method that gets no parameters and returns the type of the Outbound Port (and not the type of the driven adapter)
* Public static factory method with a single `Properties` parameter and returns the type of the outbound port (and not the type of the driven adapter).

a| 1. Avoids ambiguity when choosing a Driven Adapter. At the moment you can only limit the search space of driven adapters on a package level.

2. Using constructors or factory methods do not require any special annotations.



| Port Adapter
a| 1. A single public constructor with a single attribute. The attribute is the concrete type of a specific port.
a| 1. A port adapter is tightly coupled to a specific port. Therefore, it gets its concrete type injected.

|===

=== Scope