= Jexxa - A hexagonal software architecture for your application
:source-highlighter: coderay
:toc:
:toc-placement: preamble
:toclevels: 4


//image::./images/Logo.jpg[align=center]

//Verwendung von überstetzten Headern
//:toc-title: Inhaltsverzeichnis
//:caution-caption: Achtung
//:important-caption: Wichtig
//:note-caption: Hinweis
//:tip-caption: Tipp
//:warning-caption: Warnung
//:appendix-caption: Anhang
//:example-caption: Beispiel
//:figure-caption: Abbildung
//:table-caption: Tabelle

// Verwende Symbole für IMPORTANT, NOTE, ...
:icons: font
// Aktivieren von Anchors für jede Section
:sectanchors:

//Hinweis: Die counter:local-table-number und counter:local-figure-number werden verwendet, damit im Fliesstext als Referenz die Nummer der Tabelle bzw. Abbildung angezeigt wird, also z.B. "wie in Abbildung 5 zu sehen ist"

[cols="1,2,3,4", options="header"]
[reftext="Tabelle {counter:local-table-number}"]
.History
|===
|Version
|Date
|Author
|Notes

|0.1
|2020-03-05
|Michael Repplinger
|initial version

|0.2
|2020-05-03
|Michael Repplinger
a|* Major update of section Vision
* Major update of section General Building Blocks
* Added section Motivation

|===

:numbered:



== Vision
Jexxa is a lightweight framework to implement business applications based on a https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/[ports and adapters] architecture.

Goal of this framework is to easily connect technology stacks to a technology agnostic business application. Ideally the main-method of your application is the only location where technology stacks are connected to your application core.

Existing frameworks such as the https://spring.io[Spring Framework] or the J2EE standard provide much more powerful features and greatly support development of complex business applications. On the other side, these frameworks can unintentionally be misused by developers from an architectural point of view. It is quite hard to maintain applications over several decades especially if such frameworks are used inside the application core.

Even though Jexxa is used within lightweight business applications it has a strong educational focus. Up to now, the main goals of this framework are:

* Become an idea how to strictly separate between technology stacks and domain logic on a code basis which is essential for durable software systems.

* Be aware which technology stacks you really required to realize the use cases of your customers. Typically, they are quite less than expected. Make it as easy as possible to replace them for your or the succeeding team maintaining the application.

* Find the right balance between the 'not invented here' syndrome, and the required time to update external dependencies of your application and to train your developer teams.

Even if you use real powerful frameworks for good reason within your application I hope that you find Jexxa helpful in some way.

== Motivation
*Durability*

When developing applications with a high durability as used in production, financial or insurance sector it is highly recommended using an architecture such as ports and adapter to strictly separate the technology stacks from the application core. A developer should only use standard features of or libraries/SDKs shipped with a programming language to develop the application core. Available frameworks should be used to attach the latest technology stacks to the application core.

Applications without well-defined boundaries between technology stacks and application core itself become hard to maintain due to following reasons:

* Replacing or adding a technology stack is hard or even impossible so that a disruptive technology causes that your application core becomes legacy.
* to the application core so that it is quite hard to replace a framework. Much worse, these applications are typically hard to maintain in the sense of adding or even updating technology stacks because the application core itself might be affected as well. In the long run, changing the application core due to new or changed business rules requires a developer that still has experience with an old version of a very specific framework.


== General Building Blocks

Jexxa uses the following general building blocks which belongs either to the __application core__ or to the  __infrastructure__ which includes all kind of technology related functionality.


[cols="1,2"]
|===
|Building Block
|Description


| Driving Adapter
a| A driving adapter belongs to the infrastructure and receives a command from a specific client such as a UI, or a console and forwards it to a specific port.

A __generic__ driving adapter encapsulate the receiving technology and is able to automatically expose the methods from all kind of connected inbound ports by using a convention. So it can be connected directly to a port.

A __receiving__ driving adapter includes only a receiving technology and must be connected to __port adapter__ which performs the mapping to a specific port. The __port adapter__ must be implemented by the application developer.


|Inbound Port
| An inbound port belongs to the application core and provides use cases that can be started by a driving adapter. Depending on the design of your application core this might be an interface, or a concrete implementation of the use cases.

|Outbound Port
| An outbound port belongs to the application core but only as interface. Typically, it can only be realized by using a specific technology stack such as a database. Since it belongs to the application, the methods of an outbound port should reflect the domain language from the application core.

|Driven Adapter
|A driven adapter belongs to the infrastructure and is a concrete implementation of a specific outbound port. A driven adapter is injected into the application core which in turns only knows about the interface.

| Port Adapter
| This kind adapter allows for mapping between different representational styles such as exposing ports of an application core via REST. In contrast to a generic driving adapter, this kind of mapping has to be implemented for each exposed port.


|===


== TODO: Describe Interaction of  building blocks

[plantuml, diagram-classes, svg, align=center]
....

package Jexxa {
[Driving Adapters]
[Driven Adapter Strategies]
}

package ApplicationCore {
[Inbound Ports]
[Outbound Ports]
}


package Infrastructure {
[Driven Adapters]
}

package Jexxa  {
}

[Driving Adapters] -right--> [Inbound Ports]
[Inbound Ports] -down-> [Outbound Ports]
[Outbound Ports] <|.. [Driven Adapters]
[Driven Adapters] o--> [Driven Adapter Strategies]


[Driving Adapters] -[hidden]-- [Driven Adapter Strategies]


....



[cols="1,2"]
|===
|Building Block
|Convention

| Driving Adapter
a| * Constructor gets a `Properties` object with all configuration information 

| Port Adapter
a| * Constructor gets a single attribute which is the port
* All other required config information must be provided by its driving adapter


|===

* Interaction of  building blocks
** DrivingAdapter ->
** -> PortAdapter (optional/ only for 1 to 1)
** -> Inbound Port
** -> Outbound Port
** -> OutboundPort Wrapper (optional to decouple generic part of driven adapter)
** -> Driven Adapter

* Driving adapter and driven adapter are stateless from a Jexxa application point of view.
* Driven adapter are stateless as well. So any repository has to manage a dataset in a way that no dedicated initialization is required.     


== TODO: Describe factories:
* General idea is
** DrivingAdapter starts the interaction => so we create them first. We can make following assumptions
*** Concrete type information class<T> is available within main because:
**** An application typically needs to explicitly decide how to expose a port.
**** Alternatively we can say that we bind a specific type
**** In case we have 1 to 1 mapping there is no other chance
*** Driving adapter needs specific configuration => In java this is typically done by Properties
***** Constructor needs a Properties
***** We have a default constructor in case no configuration is required
***** We need a special configuration interface which has to be used in main => In order to support this we have to do following steps => 1. Create an adapter => 2. register port(s) => 3. configure adapter (optional) => 4. start adapter  => From point of main application we bind an adapter to a port (step 1. , 2.) and then we call 4. (start all) from main => This ensures that main can do a special configuration   

** InboundPort
*** We can make following assumptions:
*** Concrete type information class<T> is available within main.
*** Constructor requires all OutboundPorts for the job of the InboundPort
*** In case special configuration from main is required we hand in this via a Properties instance
*** => Number of constructors is at max 2 (one with and one without properties, remaining parameters should only be interfaces (outbound ports) )
*** => To create an inbound port we have to instantiate driven adapter first which implements the interfaces

** Outbound port
*** Concrete Type information are not available => We have to discover them based on the interfaces we have
*** Typically we want to exchange the implementation depending on infrastructure (developing, production, ...) => We want to use some kind of factor or factory method that returns us the interface based on the properties => For simplicity we search for static factory methods which take no argument or properties and return Outbound port (interface)


* Bootstrap service
** A bootstrap service is typically a domain service which performs some initial steps before using the application core. Typical services are: Adding master data to a specific repository if required.
Note: it is important that these steps are at least initialized via the application core
because they are essential to an application service, even if some technology stacks such as liquibase is used     


* General note:
** 1 to 1 relationship between repository and aggregate
** Allocation policy for driven adapter is that they are reused by default => can be changed in settings/properties
** ApplicationService/inbound port is not an interface because it is not required. Since a port represents business logic it has in general no different implementations
 In case you have to limit the API for specific driving adapter put a port-adapter in front of the port
