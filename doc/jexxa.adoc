= Jexxa - A hexagonal software architecture for your application
:source-highlighter: coderay
:toc:
:toc-placement: preamble
:toclevels: 4


ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

//image::./images/Logo.jpg[align=center]

//Verwendung von überstetzten Headern
//:toc-title: Inhaltsverzeichnis
//:caution-caption: Achtung
//:important-caption: Wichtig
//:note-caption: Hinweis
//:tip-caption: Tipp
//:warning-caption: Warnung
//:appendix-caption: Anhang
//:example-caption: Beispiel
//:figure-caption: Abbildung
//:table-caption: Tabelle

// Verwende Symbole für IMPORTANT, NOTE, ...
:icons: font
// Aktivieren von Anchors für jede Section
:sectanchors:

//Hinweis: Die counter:local-table-number und counter:local-figure-number werden verwendet, damit im Fliesstext als Referenz die Nummer der Tabelle bzw. Abbildung angezeigt wird, also z.B. "wie in Abbildung 5 zu sehen ist"

[cols="1,2,3,4", options="header"]
[reftext="Tabelle {counter:local-table-number}"]
.History
|===
|Version
|Date
|Author
|Notes

|0.1
|2020-03-05
|Michael Repplinger
|initial version

|0.2
|2020-05-03
|Michael Repplinger
a|* Major update of section Vision
* Major update of section General Building Blocks
* Added section Motivation

|===

:numbered:



== Vision
Jexxa is a lightweight framework to implement business applications based on a https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/[ports and adapters] architecture.

Goal of this framework is to easily connect technology stacks to a technology agnostic business application. Ideally the main-method of your application is the only location where technology stacks are connected to your application core.

Existing frameworks such as the https://spring.io[Spring Framework] or the J2EE standard provide much more powerful features and greatly support development of complex business applications. On the other side, these frameworks can unintentionally be misused by developers from an architectural point of view. It is quite hard to maintain applications over several decades especially if such frameworks are used inside the application core.

Even though Jexxa is used within lightweight business applications it has a strong educational focus. Up to now, the main goals of this framework are:

* Get an idea how to strictly separate between technology stacks and domain logic on a code basis which is essential for durable software systems.

* Be aware which technology stacks you really required to realize the use cases of your customers. Typically, they are quite less than expected. Make it as easy as possible to replace them for your or the succeeding team maintaining the application.

* Find the right balance between the 'not invented here' syndrome, and the required time to update external dependencies of your application as well as to train your developer teams in new versions of these dependencies.

Even if you use real powerful frameworks for good reason within your application I hope that you find Jexxa helpful in some way.

== Motivation
The main motivation to develop this framework comes from experiences with developing and maintaining durable software systems running up to 40 years. Here, the role of a sustainable software architecture becomes an important part to support and guide the developer team which is currently responsible for this application.

When developing applications with a high durability as used in production, financial or insurance sector it is highly recommended using an architecture with a string focus on separating technology stacks from the application core, such as ports and adapters. Within the application core, a developer should only use standard features of or libraries/SDKs shipped with a programming language. Available frameworks should be used to attach the latest technology stacks to the application core.

Applications without well-defined boundaries between technology stacks and the application core become hard to maintain because changes on one side could (and in reality will) affect the other side. Typical symptoms are:

* Updating to a newer version of a technology stack is hard or even impossible so that it is much  safer to use an old version.

* Adding or replacing a technology stack is hard or even impossible so that a disruptive technology causes that your application core becomes legacy. In the long run you also need developer on a senior grade who have deep knowledge of the outdated technology stacks.

* Changes on the application core itself takes much longer time as in the beginning. In the end you need senior developers who have a deep understanding of the specific business domain, the used technology stacks and the convoluted structures of the entire application.

* In the long run such structural issues could (and in reality will) affect your enterprise architecture so that neighbored systems need to be aware and take special actions for legacy systems.  


== General Building Blocks

Jexxa has a strong focus to Domain Driven Design and uses a lot of this terminology. It uses the following general building blocks which belongs either to the __application core__ or to the  __infrastructure__ which includes all kind of technology related functionality.


[cols="1,2,2"]
|===
a|Building Block & Streotype
|General Description
|Support by Jexxa


a| Driving Adapter
\<<Driving Adapter>>
a| A driving adapter belongs to the infrastructure and receives a command from a specific client such as a UI, or a console and forwards it to a specific port.
a| Providing __generic__ driving adapters that encapsulate the receiving technology and automatically expose the methods from connected inbound ports by using a convention.

Providing __receiving__ driving adapters that include only a receiving technology and can be connected to a __port adapter__ which is implemented in the infrastructure of the application.


a|Inbound Port
\<<Port>>
| An inbound port belongs to the application core and provides use cases that can be started by a driving adapter. Depending on the design of your application core this might be an interface, or a concrete implementation of the use cases.
|Instantiation of inbound ports in the main of the application including dependency injection of required outbound ports.

a|Outbound Port
\<<Port>>
a| An outbound port belongs to the application core but only as interface. This interface is implemented in the infrastructure of the application core by using a specific technology stack such as a database driver.


a| Outbound ports are 'just' interfaces. So there is no special support in Jexxa.

IMPORTANT: Since the outbound port belongs to the application, its methods should reflect the domain language of the application core.

|Driven Adapter
\<<Driven Adapter>>

|A driven adapter belongs to the infrastructure and is a concrete implementation of a specific outbound port. A driven adapter is injected into the application core which in turns only knows about the interface.
| Providing _driven adapter strategies_ to simplify development of driven adapters of the application.

Exchanging a concrete technology strategy depending on your production requirements and/or on your software development process. For example, you can easily switch your database technology between in memory, JDBC, or key value without changing your driven adapters.


| Port Adapter
\<<Driving Adapter>>
| A port adapter allows for mapping between different representational styles such as exposing ports of an application core via RESTfulHTTP. A port adapter belongs to the infrastructure of the application and is connected to a receiving driving adapter.
| Providing receiving driving adapters that simplify the development of the port adapters.


|===


=== Interaction and Dependencies of Building Blocks




[plantuml, diagram-components, svg, align=center]
....
skinparam PackagePadding 20

package Jexxa {
[Generic Driving Adapters]  <<Driving Adapter>>
[Receiving Driving Adapters] <<Driving Adapter>>
[Driven Adapter Strategies] <<Driven Adapter Strategies>>
}

package ApplicationCore {
[Inbound Ports] <<Port>>
[Outbound Ports] <<Port>>
}


package Infrastructure {
[Port Adapters] <<Driving Adapter>>
[Driven Adapters] <<Driven Adapter>>
}


[Receiving Driving Adapters] o-right-> [Port Adapters]
[Generic Driving Adapters] o-right-> [Inbound Ports]

[Port Adapters] *-right-> [Inbound Ports]
[Inbound Ports] o-down-> [Outbound Ports]
[Outbound Ports] <|.. [Driven Adapters]
[Driven Adapters] o-left-[Driven Adapter Strategies]


[Generic Driving Adapters] -[hidden]- [Port Adapters]
[Generic Driving Adapters] --[hidden]- [Receiving Driving Adapters]
[Receiving Driving Adapters] -[hidden]-- [Driven Adapter Strategies]
[Port Adapters] -[hidden]-- [Driven Adapters]


....



== Conventions used in Jexxa

Within Jexxa we use several conventions which should it makes hard to misuse this framework. The usage of conventions avoids using any other java specific features such as annotations. In addition, it should support understanding `why` and not only `how` things are done.


[cols="1,3,2"]
|===
a|Building Block
|Conventions
|Reason


a| Generic Driving Adapter
a| 1. To create a Driving Adapter by Jexxa, one of the following creating methods must be available.
* Public Default constructor available
* Public constructor with a single `Properties` attribute
* Public static factory method that gets no parameters and returns the type of the driving adapter
* Public static factory method with a single Properties parameter and returns the type of the requested driving adapter
Note this is the same Properties object that is given to `JexxaMain`

2. A Generic driving adapter is a singleton and reused when it is bind to different ports.
3. In `JexxaMain` the concrete Class-information is specified to instantiate the Driving Adapter.

a| 1. Using constructors or factory methods do not require any special annotations. Using `Properties` is a standard approach in Java.
2. Is required because a generic driving adapter also encapsulates the transport mechanism which typically binds other resources like a network port. Therefore, a second instance at least with same configuration is not possible.
3. Required to instantiate concrete Driving Adapter in main-method.

a|Inbound Port
a| 1. Constructor of the inbound port only has interfaces of required outbound ports as parameter.
2. An Inbound port is a singleton and reused if it is connected to different driving adapters.

a| 1. All parts of the application core should be self-contained as much as possible. The infrastructure should only be aware of the interfaces of or required by the application core but not of its inner components. Therefore, only outbound ports are allowed in a constructor.
2. This decision should:
* Simplify implementing synchronization of parallel processing from different driving adapters.
* Support designing stateless ports 


a|Outbound Port
a| None
a| None


|Driven Adapter

a| 1. Only a single implementation of an outbound port exist.
2. To create a Driven Adapter by Jexxa, one of the following constructing methods must be available.
* Public Default constructor
* Public constructor with a single `Properties` attribute
* Public static factory method that gets no parameters and returns the type of the Outbound Port
* Public static factory method with a single Properties parameter and returns the type of the outbound port.

a| 1. Jexxa provides no mechanism to explicitly define a specific driven adapter. At the moment you can only limit the search space of driven adapters on a package level.

2. Using constructors or factory methods do not require any special annotations.



| Port Adapter
a| 1. A single public constructor with a single attribute. The attribute is the concrete type of the corresponding port.
a| 1. A port adapter is tightly coupled to a specific port. Therefore, it gets its concrete type injected.


|===

