= Jexxa - A hexagonal software architecture for your application
:source-highlighter: coderay
:toc:
:toc-placement: preamble
:toclevels: 4


//image::./images/Logo.jpg[align=center]

//Verwendung von überstetzten Headern
:toc-title: Inhaltsverzeichnis
:caution-caption: Achtung
:important-caption: Wichtig
:note-caption: Hinweis
:tip-caption: Tipp
:warning-caption: Warnung
:appendix-caption: Anhang
:example-caption: Beispiel
:figure-caption: Abbildung
:table-caption: Tabelle

// Verwende Symbole für IMPORTANT, NOTE, ...
:icons: font
// Aktivieren von Anchors für jede Section
:sectanchors:

//Hinweis: Die counter:local-table-number und counter:local-figure-number werden verwendet, damit im Fliesstext als Referenz die Nummer der Tabelle bzw. Abbildung angezeigt wird, also z.B. "wie in Abbildung 5 zu sehen ist"

[cols="1,2,3,4", options="header"]
[reftext="Tabelle {counter:local-table-number}"]
.Historie
|===
|Version
|Datum
|Autor
|Notes

|0.1
|2020-03-05
|Michael Repplinger
|initial version

|0.2
|2020-05-03
|Michael Repplinger
a|* Major update of section Vision
* Added section Motivation

|===

:numbered:



== Vision
Jexxa is a lightweight framework to implement business applications based on a https://www.thinktocode.com/2018/07/19/ports-and-adapters-architecture/[ports and adapters] architecture.

Goal of this framework is to easily connect technology stacks to a technology agnostic business application. Ideally the main-method of your application is the only location where technology stacks are connected to your application core.

Existing frameworks such as the https://spring.io[Spring Framework] or the J2EE standard provide much more powerful features and greatly support development of complex business applications. On the other side, these frameworks can unintentionally be misused by developers from an architectural point of view. It is quite hard to maintain applications over several decades especially if such frameworks are used inside the application core.

Even though Jexxa is used within lightweight business applications it has a strong educational focus. Up to now, the main goals of this framework are:

* Become an idea how to strictly separate between technology stacks and domain logic on a code basis which is essential for durable software systems.

* Be aware which technology stacks you really require to realize the use cases of your customers. Typically, they are quite less than expected. Make it as easy as possible to replace them for your or the succeeding team maintaining the application.

* Find the right balance between the 'not invented here' syndrome, and the required time to update external dependencies of your application and to train your developer teams.

Even if you use real powerful frameworks for good reason within your application I hope that Jexxa gives you some ideas and helps you to think about your current and future code.

== Motivation
*Durability*

When developing applications with a high durability as used in production, financial or insurance sector it is highly recommended using an architecture such as ports and adapter to strictly separate the technology stacks from the application core. A developer should only use standard features of or libraries/SDKs shipped with a programming language to develop the application core. Available frameworks should be used to attach the latest technology stacks to the application core.

Applications without well-defined boundaries between technology stacks and application core itself become hard to maintain due to following reasons:

* Replacing or adding a technology stack is hard or even impossible so that a disruptive technology causes that your application core becomes legacy.
* to the application core so that it is quite hard to replace a framework. Much worse, these applications are typically hard to maintain in the sense of adding or even updating technology stacks because the application core itself might be affected as well. In the long run, changing the application core due to new or changed business rules requires a developer that still has experience with an old version of a very specific framework.






== TODO: Describe general building blocks

** Inbound Ports =>  Concrete implementation (Interfaces only required if Inbound ports change => In case of business logic this is quite unusual)
** Outbound ports => Interfaces that are used within the application core. When creating anm inbound port we have to set/pass implementation of these interfaces inside the application core

** Driving Adapter => Concrete implementation of a technology stack to receive commands/domain events and invoke methods of an inbound port. We have two kind if Driving Adapter
*** 1 to n assignment
*** 1 to 1 assignment

** Driven Adapter => Implementing interfaces of outbound ports
**** Direct inheritance
**** Wrapper approach


== TODO: Describe Interaction of  building blocks
* Interaction of  building blocks
** DrivingAdapter ->
** -> PortAdapter (optional/ only for 1 to 1)
** -> Inbound Port
** -> Outbound Port
** -> OutboundPort Wrapper (optional to decouple generic part of driven adapter)
** -> Driven Adapter

* Driving adapter and driven adapter are stateless from a Jexxa application point of view.
* Driven adapter are stateless as well. So any repository has to manage a dataset in a way that no dedicated initialization is required.     


== TODO: Describe factories:
* General idea is
** DrivingAdapter starts the interaction => so we create them first. We can make following assumptions
*** Concrete type information class<T> is available within main because:
**** An application typically needs to explicitly decide how to expose a port.
**** Alternatively we can say that we bind a specific type
**** In case we have 1 to 1 mapping there is no other chance
*** Driving adapter needs specific configuration => In java this is typically done by Properties
***** Constructor needs a Properties
***** We have a default constructor in case no configuration is required
***** We need a special configuration interface which has to be used in main => In order to support this we have to do following steps => 1. Create an adapter => 2. register port(s) => 3. configure adapter (optional) => 4. start adapter  => From point of main application we bind an adapter to a port (step 1. , 2.) and then we call 4. (start all) from main => This ensures that main can do a special configuration   

** InboundPort
*** We can make following assumptions:
*** Concrete type information class<T> is available within main.
*** Constructor requires all OutboundPorts for the job of the InboundPort
*** In case special configuration from main is required we hand in this via a Properties instance
*** => Number of constructors is at max 2 (one with and one without properties, remaining parameters should only be interfaces (outbound ports) )
*** => To create an inbound port we have to instantiate driven adapter first which implements the interfaces

** Outbound port
*** Concrete Type information are not available => We have to discover them based on the interfaces we have
*** Typically we want to exchange the implementation depending on infrastructure (developing, production, ...) => We want to use some kind of factor or factory method that returns us the interface based on the properties => For simplicity we search for static factory methods which take no argument or properties and return Outbound port (interface)


* Bootstrap service
** A bootstrap service is typically a domain service which performs some initial steps before using the application core. Typical services are: Adding master data to a specific repository if required.
Note: it is important that these steps are at least initialized via the application core
because they are essential to an application service, even if some technology stacks such as liquibase is used     


* General note:
** 1 to 1 relationship between repository and aggregate
** Allocation policy for driven adapter is that they are reused by default => can be changed in settings/properties
** ApplicationService/inbound port is not an interface because it is not required. Since a port represents business logic it has in general no different implementations
 In case you have to limit the API for specific driving adapter put a port-adapter in front of the port
