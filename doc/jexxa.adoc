= Jexxa - A hexagonal software architecture for your application
:source-highlighter: coderay
:toc:
:toc-placement: preamble
:toclevels: 4


//image::./images/Logo.jpg[align=center]

//Verwendung von überstetzten Headern
//:toc-title: Inhaltsverzeichnis
//:caution-caption: Achtung
//:important-caption: Wichtig
//:note-caption: Hinweis
//:tip-caption: Tipp
//:warning-caption: Warnung
//:appendix-caption: Anhang
//:example-caption: Beispiel
//:figure-caption: Abbildung
//:table-caption: Tabelle

// Verwende Symbole für IMPORTANT, NOTE, ...
:icons: font
// Aktivieren von Anchors für jede Section
:sectanchors:

//Hinweis: Die counter:local-table-number und counter:local-figure-number werden verwendet, damit im Fliesstext als Referenz die Nummer der Tabelle bzw. Abbildung angezeigt wird, also z.B. "wie in Abbildung 5 zu sehen ist"

[cols="1,2,3,4", options="header"]
[reftext="Tabelle {counter:local-table-number}"]
.History
|===
|Version
|Date
|Author
|Notes

|0.1
|2020-03-05
|Michael Repplinger
|initial version

|0.2
|2020-05-03
|Michael Repplinger
a|* Major update of section Vision
* Major update of section General Building Blocks
* Added section Motivation

|===

:numbered:



== Vision
Jexxa is a lightweight framework to implement business applications based on a https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/[ports and adapters] architecture.

Goal of this framework is to easily connect technology stacks to a technology agnostic business application. Ideally the main-method of your application is the only location where technology stacks are connected to your application core.

Existing frameworks such as the https://spring.io[Spring Framework] or the J2EE standard provide much more powerful features and greatly support development of complex business applications. On the other side, these frameworks can unintentionally be misused by developers from an architectural point of view. It is quite hard to maintain applications over several decades especially if such frameworks are used inside the application core.

Even though Jexxa is used within lightweight business applications it has a strong educational focus. Up to now, the main goals of this framework are:

* Get an idea how to strictly separate between technology stacks and domain logic on a code basis which is essential for durable software systems.

* Be aware which technology stacks you really required to realize the use cases of your customers. Typically, they are quite less than expected. Make it as easy as possible to replace them for your or the succeeding team maintaining the application.

* Find the right balance between the 'not invented here' syndrome, and the required time to update external dependencies of your application as well as to train your developer teams in new versions of these dependencies.

Even if you use real powerful frameworks for good reason within your application I hope that you find Jexxa helpful in some way.

== Motivation
The main motivation to develop this framework comes from experiences with developing and maintaining durable software systems running up to 40 years. Here, the role of a sustainable software architecture becomes an important part to support and guide the developer team which is currently responsible for this application.

When developing applications with a high durability as used in production, financial or insurance sector it is highly recommended using an architecture with a string focus on separating technology stacks from the application core, such as ports and adapters. Within the application core, a developer should only use standard features of or libraries/SDKs shipped with a programming language. Available frameworks should be used to attach the latest technology stacks to the application core.

Applications without well-defined boundaries between technology stacks and the application core become hard to maintain because changes on one side could (and in reality will) affect the other side. Typical symptoms are:

* Updating to a newer version of a technology stack is hard or even impossible so that it is much  safer to use an old version.

* Adding or replacing a technology stack is hard or even impossible so that a disruptive technology causes that your application core becomes legacy. In the long run you also need developer on a senior grade who have deep knowledge of the outdated technology stacks.

* Changes on the application core itself takes much longer time as in the beginning. In the end you need senior developers who have a deep understanding of the specific business domain, the used technology stacks and the convoluted structures of the entire application.

* In the long run such structural issues could (and in reality will) affect your enterprise architecture so that neighbored systems need to be aware and take special actions for legacy systems.  


== General Building Blocks

Jexxa has a strong focus to Domain Driven Design and uses a lot of this terminology. It uses the following general building blocks which belongs either to the __application core__ or to the  __infrastructure__ which includes all kind of technology related functionality.


[cols="1,2,2"]
|===
a|Building Block & Streotype
|General Description
|Support by Jexxa


a| Driving Adapter
\<<Driving Adapter>>
a| A driving adapter belongs to the infrastructure and receives a command from a specific client such as a UI, or a console and forwards it to a specific port.
a| Providing __generic__ driving adapters that encapsulate the receiving technology and automatically expose the methods from connected inbound ports by using a convention.

Providing __receiving__ driving adapters that include only a receiving technology and can be connected to a __port adapter__ which is implemented in the infrastructure of the application.


a|Inbound Port
\<<Port>>
| An inbound port belongs to the application core and provides use cases that can be started by a driving adapter. Depending on the design of your application core this might be an interface, or a concrete implementation of the use cases.
|Instantiation of inbound ports in the main of the application including dependency injection of required outbound ports.

a|Outbound Port
\<<Port>>
a| An outbound port belongs to the application core but only as interface. This interface is implemented in the infrastructure of the application core by using a specific technology stack such as a database driver.


a| Outbound ports are 'just' interfaces. So there is no special support in Jexxa.

IMPORTANT: Since the outbound port belongs to the application, its methods should reflect the domain language of the application core.

|Driven Adapter
\<<Driven Adapter>>

|A driven adapter belongs to the infrastructure and is a concrete implementation of a specific outbound port. A driven adapter is injected into the application core which in turns only knows about the interface.
| Providing _driven adapter strategies_ to simplify development of driven adapters of the application.

Exchanging a concrete technology strategy depending on your production requirements and/or on your software development process. For example, you can easily switch your database technology between in memory, JDBC, or key value without changing your driven adapters.


| Port Adapter
\<<Driving Adapter>>
| A port adapter allows for mapping between different representational styles such as exposing ports of an application core via RESTfulHTTP. A port adapter belongs to the infrastructure of the application and is connected to a receiving driving adapter.
| Providing receiving driving adapters that simplify the development of the port adapters.


|===


=== Interaction and Dependencies of Building Blocks




[plantuml, diagram-components, svg, align=center]
....
skinparam PackagePadding 20

package Jexxa {
[Generic Driving Adapters]  <<Driving Adapter>>
[Receiving Driving Adapters] <<Driving Adapter>>
[Driven Adapter Strategies] <<Driven Adapter>>
}

package ApplicationCore {
[Inbound Ports] <<Port>>
[Outbound Ports] <<Port>>
}


package Infrastructure {
[Port Adapters] <<Driving Adapter>>
[Driven Adapters] <<Driven Adapter>>
}


[Receiving Driving Adapters] -right-> [Port Adapters]
[Generic Driving Adapters] -right-> [Inbound Ports]

[Port Adapters] -right-> [Inbound Ports]
[Inbound Ports] -down-> [Outbound Ports]
[Outbound Ports] <|.. [Driven Adapters]
[Driven Adapters] o-left-[Driven Adapter Strategies]


[Generic Driving Adapters] -[hidden]- [Port Adapters]
[Generic Driving Adapters] --[hidden]- [Receiving Driving Adapters]
[Receiving Driving Adapters] -[hidden]-- [Driven Adapter Strategies]
[Port Adapters] -[hidden]-- [Driven Adapters]


....




== TODO: Describe factories:
* General idea is
** DrivingAdapter starts the interaction => so we create them first. We can make following assumptions
*** Concrete type information class<T> is available within main because:
**** An application typically needs to explicitly decide how to expose a port.
**** Alternatively we can say that we bind a specific type
**** In case we have 1 to 1 mapping there is no other chance
*** Driving adapter needs specific configuration => In java this is typically done by Properties
***** Constructor needs a Properties
***** We have a default constructor in case no configuration is required
***** We need a special configuration interface which has to be used in main => In order to support this we have to do following steps => 1. Create an adapter => 2. register port(s) => 3. configure adapter (optional) => 4. start adapter  => From point of main application we bind an adapter to a port (step 1. , 2.) and then we call 4. (start all) from main => This ensures that main can do a special configuration   

** InboundPort
*** We can make following assumptions:
*** Concrete type information class<T> is available within main.
*** Constructor requires all OutboundPorts for the job of the InboundPort
*** In case special configuration from main is required we hand in this via a Properties instance
*** => Number of constructors is at max 2 (one with and one without properties, remaining parameters should only be interfaces (outbound ports) )
*** => To create an inbound port we have to instantiate driven adapter first which implements the interfaces

** Outbound port
*** Concrete Type information are not available => We have to discover them based on the interfaces we have
*** Typically we want to exchange the implementation depending on infrastructure (developing, production, ...) => We want to use some kind of factor or factory method that returns us the interface based on the properties => For simplicity we search for static factory methods which take no argument or properties and return Outbound port (interface)


* Bootstrap service
** A bootstrap service is typically a domain service which performs some initial steps before using the application core. Typical services are: Adding master data to a specific repository if required.
Note: it is important that these steps are at least initialized via the application core
because they are essential to an application service, even if some technology stacks such as liquibase is used     


* General note:
** 1 to 1 relationship between repository and aggregate
** Allocation policy for driven adapter is that they are reused by default => can be changed in settings/properties
** ApplicationService/inbound port is not an interface because it is not required. Since a port represents business logic it has in general no different implementations
 In case you have to limit the API for specific driving adapter put a port-adapter in front of the port
